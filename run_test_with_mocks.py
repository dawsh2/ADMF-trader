#!/usr/bin/env python
"""
General test runner that uses mock Event classes for any test file.
"""

import argparse
import subprocess
import sys
import os
import importlib.util
import time

def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Run tests with mock Event classes")
    
    # Test file selection
    parser.add_argument(
        "file", nargs="?", default=None,
        help="Path to test file or directory (default: tests)"
    )
    
    # Output options
    parser.add_argument(
        "--verbose", "-v", action="count", default=0,
        help="Increase verbosity (can be used multiple times)"
    )
    
    # Timeout
    parser.add_argument(
        "--timeout", type=int, default=30,
        help="Timeout in seconds (default: 30)"
    )
    
    # Test method
    parser.add_argument(
        "--method", type=str, default=None,
        help="Run a specific test method"
    )
    
    # Mock options
    parser.add_argument(
        "--no-mock", action="store_true",
        help="Disable Event class mocking"
    )
    
    return parser.parse_args()

def check_dependencies():
    """Check if required dependencies are installed."""
    missing_deps = []
    
    # List of required dependencies for testing
    required_deps = [
        "pytest",
        "pytest_cov",
    ]
    
    for dep in required_deps:
        if importlib.util.find_spec(dep) is None:
            missing_deps.append(dep.replace("_", "-"))
    
    if missing_deps:
        print("Missing required dependencies:")
        for dep in missing_deps:
            print(f"  - {dep}")
        print("\nPlease install the missing dependencies:")
        print(f"pip install {' '.join(missing_deps)}")
        return False
    
    return True

def create_env_with_pythonpath():
    """Create environment with PYTHONPATH set."""
    env = os.environ.copy()
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    # Set PYTHONPATH environment variable
    if 'PYTHONPATH' in env:
        env['PYTHONPATH'] = f"{project_root}:{env['PYTHONPATH']}"
    else:
        env['PYTHONPATH'] = project_root
        
    return env, project_root

def create_mock_patcher():
    """Create a temporary script that patches sys.modules."""
    script_path = os.path.join(os.path.dirname(__file__), "tests/temp_patch_module.py")
    
    with open(script_path, "w") as f:
        f.write("""
# This file is automatically generated to patch sys.modules for testing
import sys
import os

# Add tests directory to Python path so we can import mocks
tests_dir = os.path.dirname(os.path.abspath(__file__))
if tests_dir not in sys.path:
    sys.path.insert(0, tests_dir)

# Import mock classes
from mocks.event_mocks import MockEvent, MockEventType

# Create patch for event_types module
def patch_event_types():
    # Create mock module
    import types
    mock_module = types.ModuleType('src.core.events.event_types')
    
    # Add mock classes
    mock_module.Event = MockEvent
    mock_module.EventType = MockEventType
    
    # Replace in sys.modules if it exists
    if 'src.core.events.event_types' in sys.modules:
        sys.modules['src.core.events.event_types_original'] = sys.modules['src.core.events.event_types']
    
    # Add our mock module
    sys.modules['src.core.events.event_types'] = mock_module
    print("Patched event_types module with mocks")

# Apply patch
patch_event_types()
""")
    
    return script_path

def build_command(args, mock_patcher=None):
    """Build pytest command based on arguments."""
    cmd = ["python", "-m", "pytest"]
    
    # Add verbosity
    if args.verbose > 0:
        cmd.append("-" + "v" * args.verbose)
    
    # Add mocking if enabled
    if not args.no_mock and mock_patcher:
        cmd.append("-xvs")  # Ensure we see import output
        cmd.extend(["-p", "no:cacheprovider"])  # Disable cache
        cmd.extend(["--import-mode=importlib"])  # Use importlib mode
        cmd.extend([f"--setup-only={mock_patcher}"])  # Run setup script
    
    # Add test method if specified
    if args.method:
        if args.file:
            cmd.append(f"{args.file}::{args.method}")
        else:
            print("Error: --method requires a test file")
            sys.exit(1)
    else:
        # Add test file or default to all tests
        cmd.append(args.file or "tests")
    
    return cmd

def main():
    """Main function."""
    args = parse_args()
    
    # Check dependencies
    if not check_dependencies():
        return 1
    
    # Set up environment
    env, project_root = create_env_with_pythonpath()
    print(f"PYTHONPATH set to: {env['PYTHONPATH']}")
    
    # Create mock patcher if mocking is enabled
    mock_patcher = None
    if not args.no_mock:
        try:
            mock_patcher = create_mock_patcher()
            print(f"Created mock patcher at {mock_patcher}")
        except Exception as e:
            print(f"Error creating mock patcher: {e}")
            return 1
    
    # Build command
    cmd = build_command(args, mock_patcher)
    print(f"Running: {' '.join(cmd)}")
    
    # Run command with timeout
    start_time = time.time()
    try:
        result = subprocess.run(cmd, timeout=args.timeout, env=env)
        elapsed = time.time() - start_time
        print(f"\nTests completed in {elapsed:.2f} seconds with exit code {result.returncode}")
        return result.returncode
    except subprocess.TimeoutExpired:
        print(f"\nTests timed out after {args.timeout} seconds!")
        return 1
    finally:
        # Clean up mock patcher
        if mock_patcher and os.path.exists(mock_patcher):
            os.remove(mock_patcher)
            print(f"Removed temporary mock patcher")

if __name__ == "__main__":
    sys.exit(main())
