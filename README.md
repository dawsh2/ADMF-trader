# ADMF-Trader: Modular Algorithmic Trading Framework

ADMF-Trader is a component-based, event-driven framework for algorithmic trading strategy development, optimization, and backtesting.

## Core Architecture

The system follows a hierarchical component architecture with clean separation of concerns:

```
┌───────────┐    ┌───────────┐    ┌──────────┐    ┌───────────┐
│ Market    │    │ Technical │    │ Features │    │ Trading   │
│ Data      │───>│ Indicators│───>│          │───>│ Rules     │
└───────────┘    └───────────┘    └──────────┘    └───────────┘
                                                       │
                                                       ▼
┌───────────┐    ┌───────────┐    ┌──────────┐    ┌───────────┐
│ Order     │<───│ Risk      │<───│ Strategy │<───│ Signal    │
│ Generation│    │ Management│    │          │    │ Generation│
└───────────┘    └───────────┘    └──────────┘    └───────────┘
```

### Key Components

- **Event System**: Core event bus and event handling mechanisms
- **Data Module**: Market data sources and transformations
- **Strategy Module**: Multi-level strategy components
- **Risk Module**: Portfolio tracking and position sizing
- **Execution Module**: Order and execution management
- **Analytics**: Performance metrics and reporting
- **Optimization**: Strategy parameter optimization

## Strategy Component Hierarchy

All trading elements inherit from a common `Component` base class with a hierarchical structure:

```
Component (Base)
├── Indicator
│   ├── MovingAverage
│   ├── RSI
│   ├── MACD
│   └── ...
├── Feature
│   ├── TrendStrength
│   ├── VolatilityLevel
│   ├── SupportResistance
│   └── ...
├── Rule
│   ├── MACrossover
│   ├── RSIThreshold
│   ├── BreakoutRule
│   └── ...
└── Strategy
    ├── BasicStrategy
    ├── CompositeStrategy
    │   └── RegimeStrategy
    └── ...
```

## Dependency Injection & Configuration

ADMF-Trader uses a robust DI/config system for all components:

- **Centralized Configuration**: YAML-based with environment variable support
- **Dependency Injection**: Automatic component creation and dependency resolution
- **Component Registry**: Dynamic discovery and management of components
- **Bootstrap Pattern**: Clean system initialization and setup

## Event Flow

The system follows a well-defined event flow:

1. **Market Data → Bar Events**: Sourced from files, APIs, or live feeds
2. **Bar Events → Signal Events**: Generated by strategies based on indicators and rules
3. **Signal Events → Order Events**: Transformed by risk management rules
4. **Order Events → Fill Events**: Handled by broker interfaces
5. **Fill Events → Portfolio Updates**: Impact positions and equity

## Centralized Order Registry

Order lifecycle is managed through a centralized registry:

- **Single Source of Truth**: All components reference the same order state
- **State Machine**: Validated order state transitions
- **Audit Trail**: Complete history of all order events
- **Thread Safety**: Atomic operations for concurrent processing

## Project Structure

```
src/
├── core/
│   ├── events/               # Event system
│   ├── config/               # Configuration
│   ├── di/                   # Dependency injection
│   └── utils/                # Common utilities
├── data/
│   ├── sources/              # Data sources
│   ├── transformers/         # Data transformations
│   └── handlers/             # Data handling
├── strategy/
│   ├── components/           # Strategy components
│   │   ├── indicators/       # Technical indicators
│   │   ├── features/         # Feature extraction
│   │   └── rules/            # Trading rules
│   ├── implementations/      # Concrete strategies
│   └── optimization/         # Strategy optimization
├── risk/
│   ├── portfolio/            # Portfolio state
│   └── managers/             # Risk managers
├── execution/
│   ├── broker/               # Broker interfaces
│   ├── backtest/             # Backtesting tools
│   └── order_manager.py      # Order management
└── analytics/
    ├── metrics/              # Performance metrics
    └── reporting/            # Report generation
```

## Usage Example

```python
def main():
    # Initialize bootstrap
    bootstrap = Bootstrap(config_files=["config.yaml"])
    container, config = bootstrap.setup()
    
    # Run backtest
    backtest = container.get("backtest")
    result = backtest.run(
        start_date=datetime.datetime(2020, 1, 1),
        end_date=datetime.datetime(2020, 12, 31),
        symbols=["AAPL", "MSFT"]
    )
    
    # Generate report
    report_generator = container.get("report_generator")
    report = report_generator.generate_detailed_report()
    report_generator.save_report(report, "backtest_report.txt")
```

## Running a Backtest

To run a backtest:

1. Create a configuration file (see `config/backtest.yaml`)
2. Run the backtest script:
   ```bash
   python scripts/run_backtest.py --config config/backtest.yaml --output-dir results
   ```

## Development Status

- **Core Event System**: Complete
- **Data Handling**: Complete
- **Strategy Framework**: Complete
- **Risk Management**: Complete
- **Order Registry**: Complete
- **Backtest Engine**: Complete
- **Performance Analytics**: Complete
- **Optimization Framework**: In Progress

## Next Steps

1. **Regime Detection**: Complete regime detection components
2. **Visualization**: Implement standard performance charts
3. **Advanced Optimization**: Implement parameter space optimization
4. **Paper Trading Integration**: Prepare for live testing

## Best Practices

1. **Use Dependency Injection**: Let the container manage dependencies
2. **Centralize Configuration**: All parameters should come from config
3. **Follow Event Flow**: Respect the component responsibility chain
4. **Component Registration Order**: Pay attention to event handler registration
5. **Test Components in Isolation**: Use the DI container for testing

## License

TBD
