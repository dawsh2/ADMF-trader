#!/usr/bin/env python
"""
Validation script for ADMF-Trader backtests.

This script manually implements a simple MA crossover strategy on the MINI_1min.csv
data and calculates expected trade statistics to validate the trading system.
"""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import logging
import os
import math

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("validation")

def load_data(file_path):
    """Load the data from CSV file."""
    logger.info(f"Loading data from {file_path}")
    df = pd.read_csv(file_path)
    
    # Parse timestamp column
    if 'timestamp' in df.columns:
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df.set_index('timestamp', inplace=True)
    elif 'date' in df.columns:
        df['timestamp'] = pd.to_datetime(df['date'])
        df.set_index('timestamp', inplace=True)
        df.drop('date', axis=1, inplace=True, errors='ignore')
    
    logger.info(f"Loaded {len(df)} bars from {df.index.min()} to {df.index.max()}")
    return df

def calculate_moving_averages(df, fast_window=5, slow_window=15):
    """Calculate fast and slow moving averages."""
    df['fast_ma'] = df['close'].rolling(window=fast_window).mean()
    df['slow_ma'] = df['close'].rolling(window=slow_window).mean()
    
    # Remove NaN rows
    df = df.dropna()
    return df

def generate_signals(df):
    """Generate buy/sell signals based on MA crossovers."""
    # Initialize signal column
    df['signal'] = 0
    
    # Previous MA values
    df['prev_fast_ma'] = df['fast_ma'].shift(1)
    df['prev_slow_ma'] = df['slow_ma'].shift(1)
    
    # Buy signals: fast MA crosses above slow MA
    buy_condition = (df['prev_fast_ma'] <= df['prev_slow_ma']) & (df['fast_ma'] > df['slow_ma'])
    df.loc[buy_condition, 'signal'] = 1
    
    # Sell signals: fast MA crosses below slow MA
    sell_condition = (df['prev_fast_ma'] >= df['prev_slow_ma']) & (df['fast_ma'] < df['slow_ma'])
    df.loc[sell_condition, 'signal'] = -1
    
    # Drop rows with NaN (from the shift operation)
    df = df.dropna()
    
    return df

def simulate_trades(df, initial_cash=100000.0, position_size=100, value_limit_pct=0.1):
    """Simulate trades and calculate P&L."""
    # Initialize portfolio and position tracking
    cash = initial_cash
    position = 0
    trades = []
    equity_curve = []
    
    # Record initial state
    equity_curve.append({
        'timestamp': df.index[0],
        'cash': cash,
        'position_value': 0,
        'equity': cash
    })
    
    # Process each bar
    for idx, row in df.iterrows():
        # Check if we have a signal
        if row['signal'] != 0:
            # Determine trade direction and price
            direction = 'BUY' if row['signal'] > 0 else 'SELL'
            price = row['close']
            
            # Apply slippage (0.1%)
            if direction == 'BUY':
                execution_price = price * 1.001
            else:
                execution_price = price * 0.999
            
            # Calculate position size
            if direction == 'BUY':
                # Limit position size based on cash
                max_position = min(position_size, int((cash * value_limit_pct) / execution_price))
                # Adjust if not enough cash
                if max_position <= 0:
                    logger.warning(f"Not enough cash to execute BUY at {idx}")
                    continue
                    
                # Execute buy
                trade_value = max_position * execution_price
                cash -= trade_value
                position += max_position
                
                trades.append({
                    'timestamp': idx,
                    'direction': direction,
                    'quantity': max_position,
                    'price': execution_price,
                    'value': trade_value,
                    'pnl': 0.0,  # No P&L on entry
                    'position_after': position,
                    'cash_after': cash
                })
                
            else:  # SELL
                # Check if we have a position to sell
                if position <= 0:
                    logger.warning(f"No position to SELL at {idx}")
                    continue
                
                # Limit sell size to current position
                sell_size = min(position_size, position)
                
                # Execute sell
                trade_value = sell_size * execution_price
                cash += trade_value
                
                # Calculate P&L
                # Simple approach: Use average price of prior buys
                avg_buy_price = sum([t['price'] * t['quantity'] for t in trades if t['direction'] == 'BUY']) / \
                                sum([t['quantity'] for t in trades if t['direction'] == 'BUY'])
                
                pnl = (execution_price - avg_buy_price) * sell_size
                position -= sell_size
                
                trades.append({
                    'timestamp': idx,
                    'direction': direction,
                    'quantity': sell_size,
                    'price': execution_price,
                    'value': trade_value,
                    'pnl': pnl,
                    'position_after': position,
                    'cash_after': cash
                })
        
        # Update equity curve at each step
        position_value = position * row['close'] if position > 0 else 0
        equity = cash + position_value
        
        equity_curve.append({
            'timestamp': idx,
            'cash': cash,
            'position_value': position_value,
            'equity': equity
        })
    
    # Convert to DataFrames
    trades_df = pd.DataFrame(trades)
    equity_df = pd.DataFrame(equity_curve)
    
    return trades_df, equity_df

def calculate_performance_metrics(trades_df, equity_df):
    """Calculate key performance metrics."""
    if trades_df.empty:
        return {
            'total_trades': 0,
            'win_rate': 0,
            'profit_factor': 0,
            'avg_trade': 0,
            'total_return': 0,
            'sharpe_ratio': 0,
            'max_drawdown': 0
        }
    
    # Basic trade statistics
    total_trades = len(trades_df)
    winning_trades = len(trades_df[trades_df['pnl'] > 0])
    losing_trades = len(trades_df[trades_df['pnl'] < 0])
    
    win_rate = winning_trades / total_trades if total_trades > 0 else 0
    
    # P&L metrics
    total_pnl = trades_df['pnl'].sum()
    gross_profit = trades_df[trades_df['pnl'] > 0]['pnl'].sum() if winning_trades > 0 else 0
    gross_loss = abs(trades_df[trades_df['pnl'] < 0]['pnl'].sum()) if losing_trades > 0 else 0
    
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
    avg_trade = total_pnl / total_trades if total_trades > 0 else 0
    
    # Portfolio metrics
    initial_equity = equity_df['equity'].iloc[0]
    final_equity = equity_df['equity'].iloc[-1]
    total_return = (final_equity / initial_equity) - 1
    
    # Calculate daily returns for Sharpe ratio
    equity_df['daily_return'] = equity_df['equity'].pct_change()
    sharpe_ratio = 0
    if len(equity_df) > 1:
        mean_return = equity_df['daily_return'].mean()
        std_return = equity_df['daily_return'].std()
        if std_return > 0:
            # Annualized Sharpe (assuming daily data, âˆš252 trading days)
            sharpe_ratio = mean_return / std_return * math.sqrt(252)
    
    # Calculate maximum drawdown
    equity_df['peak'] = equity_df['equity'].cummax()
    equity_df['drawdown'] = (equity_df['equity'] - equity_df['peak']) / equity_df['peak']
    max_drawdown = abs(equity_df['drawdown'].min())
    
    return {
        'total_trades': total_trades,
        'winning_trades': winning_trades,
        'losing_trades': losing_trades,
        'win_rate': win_rate,
        'total_pnl': total_pnl,
        'profit_factor': profit_factor,
        'avg_trade': avg_trade,
        'total_return': total_return,
        'sharpe_ratio': sharpe_ratio,
        'max_drawdown': max_drawdown
    }

def plot_results(df, trades_df, equity_df):
    """Plot the strategy results."""
    plt.figure(figsize=(15, 10))
    
    # Price chart with MA lines
    plt.subplot(2, 1, 1)
    plt.plot(df.index, df['close'], label='Close Price', alpha=0.5)
    plt.plot(df.index, df['fast_ma'], label=f'Fast MA (5)', color='red')
    plt.plot(df.index, df['slow_ma'], label=f'Slow MA (15)', color='blue')
    
    # Add buy/sell markers
    buys = df[df['signal'] == 1]
    sells = df[df['signal'] == -1]
    plt.scatter(buys.index, buys['close'], marker='^', color='green', s=100, label='Buy Signal')
    plt.scatter(sells.index, sells['close'], marker='v', color='red', s=100, label='Sell Signal')
    
    plt.title('MINI Price with MA Crossover Strategy')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend()
    plt.grid(True)
    
    # Equity curve
    plt.subplot(2, 1, 2)
    plt.plot(equity_df['timestamp'], equity_df['equity'], label='Equity', color='blue')
    plt.title('Equity Curve')
    plt.xlabel('Date')
    plt.ylabel('Equity')
    plt.grid(True)
    
    plt.tight_layout()
    plt.savefig('validation_results.png')
    logger.info("Saved results plot to validation_results.png")

def main():
    """Main function to run the validation test."""
    # Set file path
    data_file = os.path.join('data', 'MINI_1min.csv')
    
    # Load and prepare data
    df = load_data(data_file)
    
    # Calculate moving averages
    df = calculate_moving_averages(df, fast_window=5, slow_window=15)
    
    # Generate signals
    df = generate_signals(df)
    
    # Count signals
    buy_signals = len(df[df['signal'] == 1])
    sell_signals = len(df[df['signal'] == -1])
    logger.info(f"Generated {buy_signals} buy signals and {sell_signals} sell signals")
    
    # Simulate trades
    trades_df, equity_df = simulate_trades(df, initial_cash=100000.0, position_size=100, value_limit_pct=0.1)
    
    # Calculate performance metrics
    metrics = calculate_performance_metrics(trades_df, equity_df)
    
    # Display results
    logger.info("==== Validation Test Results ====")
    logger.info(f"Total trades: {metrics['total_trades']}")
    logger.info(f"Win rate: {metrics['win_rate']:.2%}")
    logger.info(f"Total P&L: ${metrics['total_pnl']:.2f}")
    logger.info(f"Profit factor: {metrics['profit_factor']:.4f}")
    logger.info(f"Average trade: ${metrics['avg_trade']:.2f}")
    logger.info(f"Total return: {metrics['total_return']:.2%}")
    logger.info(f"Sharpe ratio: {metrics['sharpe_ratio']:.4f}")
    logger.info(f"Maximum drawdown: {metrics['max_drawdown']:.2%}")
    
    # Save trade log
    if not trades_df.empty:
        trades_df.to_csv('validation_trades.csv')
        logger.info("Saved trades to validation_trades.csv")
    
    # Save equity curve
    equity_df.to_csv('validation_equity.csv')
    logger.info("Saved equity curve to validation_equity.csv")
    
    # Plot results
    plot_results(df, trades_df, equity_df)
    
    return metrics

if __name__ == "__main__":
    main()
