#!/usr/bin/env python
"""
Debug script for tracking events in the ADMF-Trader system.
"""
import os
import sys
import argparse
import logging
import datetime
import pandas as pd

# Import bootstrap for clean initialization
from src.core.bootstrap import Bootstrap
from src.core.events.event_types import EventType
from src.core.events.event_bus import EventBus

# Create a custom event listener to log all events
class EventDebugger:
    """Event listener to debug events flowing through the system."""
    
    def __init__(self, event_bus):
        self.event_bus = event_bus
        self.event_counts = {event_type: 0 for event_type in EventType.__dict__.values() 
                           if isinstance(event_type, str) and not event_type.startswith('_')}
        self.events = []
        self.register_handlers()
        
    def register_handlers(self):
        """Register handlers for all event types."""
        for event_type in EventType.__dict__.values():
            if isinstance(event_type, str) and not event_type.startswith('_'):
                self.event_bus.register(event_type, self.on_event)
                
    def on_event(self, event):
        """Handler for all events."""
        self.event_counts[event.type] += 1
        self.events.append(event)
        logging.debug(f"EVENT: {event.type}, Data: {event.data}")
        
    def get_stats(self):
        """Get event statistics."""
        return {
            'total_events': len(self.events),
            'counts_by_type': self.event_counts,
            'last_events': self.events[-10:] if self.events else []
        }

def main():
    """Run a debug backtest with event tracking."""
    # Parse arguments
    parser = argparse.ArgumentParser(description="ADMF-Trader Event Debugger")
    parser.add_argument("--config", required=True, help="Configuration file path")
    parser.add_argument("--output-dir", default="./results", help="Results output directory")
    parser.add_argument("--log-level", default="DEBUG", help="Logging level")
    
    args = parser.parse_args()
    
    # Create output directory
    config_name = os.path.splitext(os.path.basename(args.config))[0]
    strategy_output_dir = os.path.join(args.output_dir, config_name)
    os.makedirs(strategy_output_dir, exist_ok=True)
    
    # Set up log file
    log_file = os.path.join(strategy_output_dir, f"{config_name}_debug.log")
    
    # Initialize the bootstrap
    bootstrap = Bootstrap(
        config_files=[args.config],
        log_level=args.log_level,
        log_file=log_file
    )
    
    # Setup container with components
    print(f"Initializing system with configuration: {args.config}")
    container, config = bootstrap.setup()
    
    # Get components
    event_bus = container.get("event_bus")
    data_handler = container.get("data_handler")
    strategy = container.get("strategy")
    
    # Add our event debugger
    event_debugger = EventDebugger(event_bus)
    
    # Get backtest coordinator
    backtest = container.get("backtest")
    
    # Run the backtest
    print("Running debug backtest...")
    results = backtest.run()
    
    # Print event stats
    stats = event_debugger.get_stats()
    print("\nEvent Statistics:")
    print(f"Total events: {stats['total_events']}")
    print("\nEvents by type:")
    for event_type, count in stats['counts_by_type'].items():
        if count > 0:
            print(f"  {event_type}: {count}")
    
    # Print signal events specifically
    signal_events = [e for e in event_debugger.events if e.type == EventType.SIGNAL]
    if signal_events:
        print(f"\nFound {len(signal_events)} signal events:")
        for i, event in enumerate(signal_events[:5]):  # Show first 5
            print(f"  Signal {i+1}: {event.data}")
        if len(signal_events) > 5:
            print(f"  ... and {len(signal_events) - 5} more")
    else:
        print("\nNo signal events were generated!")
        
        # Debug strategy data
        if hasattr(strategy, 'data'):
            symbols = list(strategy.data.keys())
            if symbols:
                symbol = symbols[0]
                data_points = len(strategy.data[symbol])
                print(f"\nStrategy collected {data_points} data points for {symbol}")
                
                if data_points > strategy.slow_window:
                    # Calculate MAs manually for verification
                    if data_points >= 20:
                        sample_points = strategy.data[symbol][-20:]
                        prices = [p['price'] for p in sample_points]
                        
                        fast_ma = sum(prices[-strategy.fast_window:]) / strategy.fast_window
                        slow_ma = sum(prices[-strategy.slow_window:]) / strategy.slow_window
                        
                        print(f"Sample of last 20 prices: {prices}")
                        print(f"Last calculated fast MA ({strategy.fast_window}): {fast_ma:.2f}")
                        print(f"Last calculated slow MA ({strategy.slow_window}): {slow_ma:.2f}")
                        print(f"Difference: {fast_ma - slow_ma:.2f}")
                    
    # Print summary
    if results:
        print("\nBacktest Results Summary:")
        trades = results.get("trades", [])
        print(f"Trades executed: {len(trades)}")
        
        # Print performance metrics if available
        metrics = results.get("metrics", {})
        if metrics:
            print(f"Total Return: {metrics.get('total_return', 0):.2%}")
            print(f"Sharpe Ratio: {metrics.get('sharpe_ratio', float('nan'))}")
            print(f"Max Drawdown: {metrics.get('max_drawdown', 0):.2%}")
    else:
        print("Backtest did not produce any results")
    
    print(f"\nDetailed logs saved to: {log_file}")
    return True

if __name__ == "__main__":
    try:
        success = main()
        sys.exit(0 if success else 1)
    except Exception as e:
        logging.exception("Debug backtest failed with error")
        print(f"Error: {e}")
        sys.exit(1)
