#!/usr/bin/env python3
"""
Debug script for analyzing the trading events flow in ADMF-trader.

This script tracks and analyzes the flow of events through the system, focusing on:
1. SIGNAL events generated by strategy
2. ORDER events generated by risk manager
3. FILL events generated by broker
4. TRADE_OPEN/TRADE_CLOSE events

It helps identify where the trading flow might be breaking down.
"""
import os
import sys
import logging
import json
import pandas as pd
import datetime
from collections import defaultdict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(f"event_flow_debug_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
    ]
)
logger = logging.getLogger("event_debug")

# Import framework components
try:
    from src.core.events.event_bus import EventBus
    from src.core.events.event_types import EventType, Event
    from src.core.di.container import Container
    from src.core.config.config import Config
    from src.execution.backtest.backtest import BacktestCoordinator
except ImportError as e:
    logger.error(f"Error importing ADMF-trader modules: {e}")
    logger.error("Make sure you're running from the project root directory")
    sys.exit(1)

class EventDebugger:
    """Event debugger to trace event flow through the system."""
    
    def __init__(self):
        """Initialize the event debugger."""
        self.signal_events = []
        self.order_events = []
        self.fill_events = []
        self.trade_open_events = []
        self.trade_close_events = []
        self.all_events = []
        
        # Track events by symbol
        self.events_by_symbol = defaultdict(lambda: defaultdict(list))
        
        # Track positions
        self.positions = defaultdict(lambda: {'quantity': 0, 'price': 0.0, 'side': None})
        
        # Original handlers
        self.original_handlers = {}
        
    def hook_event_bus(self, event_bus):
        """
        Hook into the event bus to capture all events.
        
        Args:
            event_bus: Event bus to hook into
        """
        if not event_bus:
            logger.error("No event bus provided")
            return False
            
        logger.info("Hooking into event bus")
        
        # Store original handlers for each event type
        for event_type in EventType:
            if hasattr(event_bus, 'handlers') and event_type in event_bus.handlers:
                self.original_handlers[event_type] = event_bus.handlers[event_type].copy()
            else:
                self.original_handlers[event_type] = []
        
        # Register our debug handlers with high priority
        event_bus.register(EventType.SIGNAL, self.on_signal, priority=999)
        event_bus.register(EventType.ORDER, self.on_order, priority=999)
        event_bus.register(EventType.FILL, self.on_fill, priority=999)
        event_bus.register(EventType.TRADE_OPEN, self.on_trade_open, priority=999)
        event_bus.register(EventType.TRADE_CLOSE, self.on_trade_close, priority=999)
        
        # Register for all event types to capture everything
        for event_type in EventType:
            if event_type not in [EventType.SIGNAL, EventType.ORDER, EventType.FILL, 
                                EventType.TRADE_OPEN, EventType.TRADE_CLOSE]:
                event_bus.register(event_type, self.on_other_event, priority=999)
                
        logger.info("Successfully hooked into event bus")
        return True
    
    def on_signal(self, event):
        """
        Handle signal event.
        
        Args:
            event: Signal event
        """
        logger.info(f"SIGNAL: {self._format_event(event)}")
        self.signal_events.append(self._extract_event_data(event))
        self.all_events.append(self._extract_event_data(event))
        
        # Track by symbol
        symbol = event.data.get('symbol', 'UNKNOWN')
        self.events_by_symbol[symbol]['signals'].append(self._extract_event_data(event))
        
    def on_order(self, event):
        """
        Handle order event.
        
        Args:
            event: Order event
        """
        logger.info(f"ORDER: {self._format_event(event)}")
        self.order_events.append(self._extract_event_data(event))
        self.all_events.append(self._extract_event_data(event))
        
        # Track by symbol
        symbol = event.data.get('symbol', 'UNKNOWN')
        self.events_by_symbol[symbol]['orders'].append(self._extract_event_data(event))
        
    def on_fill(self, event):
        """
        Handle fill event.
        
        Args:
            event: Fill event
        """
        logger.info(f"FILL: {self._format_event(event)}")
        self.fill_events.append(self._extract_event_data(event))
        self.all_events.append(self._extract_event_data(event))
        
        # Track by symbol
        symbol = event.data.get('symbol', 'UNKNOWN')
        self.events_by_symbol[symbol]['fills'].append(self._extract_event_data(event))
        
        # Update position
        direction = event.data.get('direction', 'UNKNOWN')
        quantity = event.data.get('size', event.data.get('quantity', 0))
        price = event.data.get('price', event.data.get('fill_price', 0.0))
        
        if direction == 'BUY':
            self.positions[symbol]['quantity'] += quantity
            self.positions[symbol]['price'] = price
            self.positions[symbol]['side'] = 'LONG'
        elif direction == 'SELL':
            self.positions[symbol]['quantity'] -= quantity
            self.positions[symbol]['price'] = price
            if self.positions[symbol]['quantity'] < 0:
                self.positions[symbol]['side'] = 'SHORT'
            elif self.positions[symbol]['quantity'] == 0:
                self.positions[symbol]['side'] = None
                
        logger.info(f"Position update for {symbol}: {self.positions[symbol]}")
        
    def on_trade_open(self, event):
        """
        Handle trade open event.
        
        Args:
            event: Trade open event
        """
        logger.info(f"TRADE_OPEN: {self._format_event(event)}")
        self.trade_open_events.append(self._extract_event_data(event))
        self.all_events.append(self._extract_event_data(event))
        
        # Track by symbol
        symbol = event.data.get('symbol', 'UNKNOWN')
        self.events_by_symbol[symbol]['trade_opens'].append(self._extract_event_data(event))
        
    def on_trade_close(self, event):
        """
        Handle trade close event.
        
        Args:
            event: Trade close event
        """
        logger.info(f"TRADE_CLOSE: {self._format_event(event)}")
        self.trade_close_events.append(self._extract_event_data(event))
        self.all_events.append(self._extract_event_data(event))
        
        # Track by symbol
        symbol = event.data.get('symbol', 'UNKNOWN')
        self.events_by_symbol[symbol]['trade_closes'].append(self._extract_event_data(event))
        
    def on_other_event(self, event):
        """
        Handle other event types.
        
        Args:
            event: Any other event
        """
        event_type = str(event.type).replace('EventType.', '')
        logger.debug(f"OTHER ({event_type}): {self._format_event(event)}")
        self.all_events.append(self._extract_event_data(event))
        
    def _format_event(self, event):
        """
        Format event data for logging.
        
        Args:
            event: Event to format
            
        Returns:
            str: Formatted event string
        """
        try:
            event_data = event.data.copy() if hasattr(event, 'data') else {}
            
            # Format common fields
            symbol = event_data.get('symbol', 'UNKNOWN')
            timestamp = getattr(event, 'timestamp', datetime.datetime.now())
            
            # Format based on event type
            if event.type == EventType.SIGNAL:
                signal_type = event_data.get('signal_type', 'UNKNOWN')
                price = event_data.get('price', 0.0)
                return f"{symbol} @ {price:.2f} - Type: {signal_type} - Time: {timestamp}"
                
            elif event.type == EventType.ORDER:
                direction = event_data.get('direction', 'UNKNOWN')
                quantity = event_data.get('size', event_data.get('quantity', 0))
                price = event_data.get('price', 0.0)
                order_id = event_data.get('order_id', 'UNKNOWN')
                position_action = event_data.get('position_action', 'UNKNOWN')
                return f"{symbol} {direction} {quantity} @ {price:.2f} - ID: {order_id} - Action: {position_action} - Time: {timestamp}"
                
            elif event.type == EventType.FILL:
                direction = event_data.get('direction', 'UNKNOWN')
                quantity = event_data.get('size', event_data.get('quantity', 0))
                price = event_data.get('price', event_data.get('fill_price', 0.0))
                order_id = event_data.get('order_id', 'UNKNOWN')
                return f"{symbol} {direction} {quantity} @ {price:.2f} - Order ID: {order_id} - Time: {timestamp}"
                
            elif event.type == EventType.TRADE_OPEN:
                direction = event_data.get('direction', 'UNKNOWN')
                quantity = event_data.get('quantity', 0)
                price = event_data.get('price', 0.0)
                transaction_id = event_data.get('transaction_id', 'UNKNOWN')
                return f"{symbol} {direction} {quantity} @ {price:.2f} - Trans ID: {transaction_id} - Time: {timestamp}"
                
            elif event.type == EventType.TRADE_CLOSE:
                direction = event_data.get('direction', 'UNKNOWN')
                quantity = event_data.get('quantity', 0)
                entry_price = event_data.get('entry_price', 0.0)
                exit_price = event_data.get('exit_price', 0.0)
                pnl = event_data.get('pnl', 0.0)
                transaction_id = event_data.get('transaction_id', 'UNKNOWN')
                return f"{symbol} {direction} {quantity} - Entry: {entry_price:.2f}, Exit: {exit_price:.2f}, PnL: {pnl:.2f} - Trans ID: {transaction_id} - Time: {timestamp}"
                
            else:
                # Generic formatting for other event types
                return f"{symbol} - {event_data} - Time: {timestamp}"
                
        except Exception as e:
            logger.error(f"Error formatting event: {e}")
            return str(event)
            
    def _extract_event_data(self, event):
        """
        Extract relevant data from an event for analysis.
        
        Args:
            event: Event to extract data from
            
        Returns:
            dict: Extracted event data
        """
        try:
            event_data = event.data.copy() if hasattr(event, 'data') else {}
            
            # Add metadata
            result = {
                'event_type': str(event.type).replace('EventType.', ''),
                'timestamp': getattr(event, 'timestamp', datetime.datetime.now()).isoformat(),
                'event_id': getattr(event, 'id', str(id(event)))
            }
            
            # Add event data
            for key, value in event_data.items():
                # Convert non-serializable objects to strings
                if isinstance(value, (datetime.datetime, datetime.date)):
                    result[key] = value.isoformat()
                else:
                    try:
                        # Try to convert to basic types
                        json.dumps({key: value})
                        result[key] = value
                    except (TypeError, OverflowError):
                        result[key] = str(value)
                        
            return result
            
        except Exception as e:
            logger.error(f"Error extracting event data: {e}")
            return {'error': str(e), 'event': str(event)}
            
    def save_events(self, output_dir='.'):
        """
        Save captured events to files.
        
        Args:
            output_dir: Directory to save event files
        """
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            
        # Save individual event types
        self._save_events_to_csv(self.signal_events, f"{output_dir}/signal_events_{timestamp}.csv")
        self._save_events_to_csv(self.order_events, f"{output_dir}/order_events_{timestamp}.csv")
        self._save_events_to_csv(self.fill_events, f"{output_dir}/fill_events_{timestamp}.csv")
        self._save_events_to_csv(self.trade_open_events, f"{output_dir}/trade_open_events_{timestamp}.csv")
        self._save_events_to_csv(self.trade_close_events, f"{output_dir}/trade_close_events_{timestamp}.csv")
        
        # Save all events in chronological order
        all_events_sorted = sorted(self.all_events, key=lambda x: x.get('timestamp', ''))
        self._save_events_to_csv(all_events_sorted, f"{output_dir}/all_events_{timestamp}.csv")
        
        # Save positions
        positions_list = [{'symbol': symbol, **position} for symbol, position in self.positions.items()]
        self._save_events_to_csv(positions_list, f"{output_dir}/final_positions_{timestamp}.csv")
        
        # Save per-symbol event analysis
        for symbol, events in self.events_by_symbol.items():
            symbol_data = {
                'signals': len(events['signals']),
                'orders': len(events['orders']),
                'fills': len(events['fills']),
                'trade_opens': len(events['trade_opens']),
                'trade_closes': len(events['trade_closes']),
                'position': self.positions.get(symbol, {'quantity': 0, 'price': 0.0, 'side': None})
            }
            
            with open(f"{output_dir}/symbol_{symbol}_summary_{timestamp}.json", 'w') as f:
                json.dump(symbol_data, f, indent=2)
                
        logger.info(f"Saved all event data to {output_dir}")
        
    def _save_events_to_csv(self, events, filename):
        """
        Save events to CSV file.
        
        Args:
            events: List of event data dictionaries
            filename: Output filename
        """
        if not events:
            logger.warning(f"No events to save to {filename}")
            return
            
        try:
            df = pd.DataFrame(events)
            df.to_csv(filename, index=False)
            logger.info(f"Saved {len(events)} events to {filename}")
        except Exception as e:
            logger.error(f"Error saving events to {filename}: {e}")
            
    def analyze_event_flow(self):
        """
        Analyze the event flow for issues.
        
        Returns:
            dict: Analysis results
        """
        analysis = {
            'event_counts': {
                'signals': len(self.signal_events),
                'orders': len(self.order_events),
                'fills': len(self.fill_events),
                'trade_opens': len(self.trade_open_events),
                'trade_closes': len(self.trade_close_events),
                'total': len(self.all_events)
            },
            'symbols': len(self.events_by_symbol),
            'flow_issues': [],
            'position_issues': []
        }
        
        # Check if signals are being converted to orders
        if len(self.signal_events) > 0 and len(self.order_events) == 0:
            analysis['flow_issues'].append("Signals are not being converted to orders. Check risk manager.")
            
        # Check if orders are being filled
        if len(self.order_events) > 0 and len(self.fill_events) == 0:
            analysis['flow_issues'].append("Orders are not being filled. Check broker simulator.")
            
        # Check if fills are generating trade events
        if len(self.fill_events) > 0 and len(self.trade_open_events) == 0:
            analysis['flow_issues'].append("Fill events are not generating trade open events. Check order manager.")
            
        # Check for trade open/close balance
        if len(self.trade_open_events) > 0 and len(self.trade_close_events) == 0:
            analysis['flow_issues'].append("No trade close events generated. Positions may be remaining open.")
            
        # Check for open positions
        for symbol, position in self.positions.items():
            if position['quantity'] != 0:
                direction = "LONG" if position['quantity'] > 0 else "SHORT"
                analysis['position_issues'].append(
                    f"Open {direction} position for {symbol}: {abs(position['quantity'])} units at {position['price']:.2f}"
                )
                
        # Check for event sequence issues per symbol
        for symbol, events in self.events_by_symbol.items():
            # Should have: signal -> order -> fill -> trade_open -> trade_close
            signal_count = len(events['signals'])
            order_count = len(events['orders'])
            fill_count = len(events['fills'])
            open_count = len(events['trade_opens'])
            close_count = len(events['trade_closes'])
            
            if signal_count > order_count:
                analysis['flow_issues'].append(
                    f"Symbol {symbol}: {signal_count} signals but only {order_count} orders"
                )
                
            if order_count > fill_count:
                analysis['flow_issues'].append(
                    f"Symbol {symbol}: {order_count} orders but only {fill_count} fills"
                )
                
            if fill_count > open_count:
                analysis['flow_issues'].append(
                    f"Symbol {symbol}: {fill_count} fills but only {open_count} trade opens"
                )
                
            if open_count > close_count:
                analysis['flow_issues'].append(
                    f"Symbol {symbol}: {open_count} trade opens but only {close_count} trade closes"
                )
                
        return analysis
        
def run_backtest_with_debugger(config_file):
    """
    Run a backtest with the event debugger attached.
    
    Args:
        config_file: Path to configuration file
        
    Returns:
        tuple: (backtest_result, debugger)
    """
    logger.info(f"Starting backtest with config: {config_file}")
    
    # Load configuration
    try:
        # Try different ways of loading configuration based on the API
        try:
            # First try the load_from_file method if it exists
            config = Config()
            if hasattr(config, 'load_from_file'):
                config.load_from_file(config_file)
            # Otherwise try the load method
            elif hasattr(config, 'load'):
                config.load(config_file)
            # Or try direct initialization with file path
            else:
                config = Config(config_file)
            logger.info("Configuration loaded successfully")
        except (AttributeError, TypeError):
            # Try alternate config loading approach
            from src.core.config.config_manager import ConfigManager
            config_manager = ConfigManager()
            config = config_manager.load_config(config_file)
            logger.info("Configuration loaded using ConfigManager")
    except Exception as e:
        logger.error(f"Error loading configuration: {e}", exc_info=True)
        return None, None
        
    # Create container
    container = Container()
    
    # Create event bus
    event_bus = EventBus()
    container.register('event_bus', event_bus)
    
    # Create debugger and hook into event bus
    debugger = EventDebugger()
    debugger.hook_event_bus(event_bus)
    
    # Create backtest coordinator
    try:
        # Register config with container
        container.register('config', config)
        
        # Create coordinator
        coordinator = BacktestCoordinator(container, config)
        
        # Setup the backtest
        setup_success = coordinator.setup()
        if not setup_success:
            logger.error("Failed to setup backtest coordinator")
            return None, debugger
            
        logger.info("Running backtest...")
        
        # Run the backtest
        result = coordinator.run()
        
        logger.info("Backtest completed")
        
        return result, debugger
        
    except Exception as e:
        logger.error(f"Error running backtest: {e}", exc_info=True)
        return None, debugger
        
def analyze_symbol_events(symbol, events_by_symbol):
    """
    Analyze the events for a specific symbol to diagnose issues.
    
    Args:
        symbol: Symbol to analyze
        events_by_symbol: Dict of events by symbol
        
    Returns:
        dict: Analysis results
    """
    if symbol not in events_by_symbol:
        return {"error": f"No events found for symbol {symbol}"}
        
    events = events_by_symbol[symbol]
    
    analysis = {
        'signals': len(events['signals']),
        'orders': len(events['orders']),
        'fills': len(events['fills']),
        'trade_opens': len(events['trade_opens']),
        'trade_closes': len(events['trade_closes']),
        'issues': []
    }
    
    # Detect MA crossovers
    if events['signals']:
        # Filter for BUY and SELL signals
        buy_signals = [s for s in events['signals'] if s.get('signal_type') == 'BUY']
        sell_signals = [s for s in events['signals'] if s.get('signal_type') == 'SELL']
        
        analysis['buy_signals'] = len(buy_signals)
        analysis['sell_signals'] = len(sell_signals)
        
        # Check if we have alternating buy/sell signals (indication of crossovers)
        if buy_signals and sell_signals:
            # Sort by timestamp
            all_signals = buy_signals + sell_signals
            all_signals.sort(key=lambda x: x.get('timestamp', ''))
            
            current_type = None
            alternating = True
            crossovers = 0
            
            for signal in all_signals:
                signal_type = signal.get('signal_type')
                if current_type == signal_type:
                    alternating = False
                else:
                    if current_type is not None:
                        crossovers += 1
                    current_type = signal_type
            
            analysis['crossovers_detected'] = crossovers
            if not alternating:
                analysis['issues'].append("Signals are not perfectly alternating - possible duplicate signals")
        
    # Check if trades are being opened and closed
    if len(events['trade_opens']) > 0 and len(events['trade_closes']) == 0:
        analysis['issues'].append(
            "Trades are being opened but never closed. Check strategy/risk manager for crossovers."
        )
        
    # Check the timestamp sequence for a complete trade lifecycle
    if events['signals'] and events['orders'] and events['fills'] and events['trade_opens']:
        # Take the first few events of each type
        sample_signals = events['signals'][:min(5, len(events['signals']))]
        sample_orders = events['orders'][:min(5, len(events['orders']))]
        sample_fills = events['fills'][:min(5, len(events['fills']))]
        sample_opens = events['trade_opens'][:min(5, len(events['trade_opens']))]
        
        # Get timestamps
        signal_times = [s.get('timestamp', '') for s in sample_signals]
        order_times = [o.get('timestamp', '') for o in sample_orders]
        fill_times = [f.get('timestamp', '') for f in sample_fills]
        open_times = [o.get('timestamp', '') for o in sample_opens]
        
        # Check sequence
        for i in range(min(len(signal_times), len(order_times), len(fill_times), len(open_times))):
            if i < len(signal_times) and i < len(order_times) and signal_times[i] > order_times[i]:
                analysis['issues'].append(
                    f"Order {i+1} was created before its signal - possible event timing issue"
                )
            
            if i < len(order_times) and i < len(fill_times) and order_times[i] > fill_times[i]:
                analysis['issues'].append(
                    f"Fill {i+1} occurred before its order - possible event timing issue"
                )
                
            if i < len(fill_times) and i < len(open_times) and fill_times[i] > open_times[i]:
                analysis['issues'].append(
                    f"Trade open {i+1} occurred before its fill - possible event timing issue"
                )
                
    return analysis
    
def create_minimal_debugger():
    """Create a minimal debugger that attaches directly to the system modules."""
    from src.core.events.event_bus import EventBus
    from src.core.events.event_types import EventType
    
    logger.info("Creating minimal event debugger")
    
    # Create our own event bus for debugging
    debugger = EventDebugger()
    
    # Find existing event bus instances
    try:
        # Try to find event bus singleton or global instance
        from src.core.di.container import Container
        container = Container()
        if container.has('event_bus'):
            event_bus = container.get('event_bus')
            logger.info("Found event bus in container")
            debugger.hook_event_bus(event_bus)
            return debugger
    except Exception as e:
        logger.warning(f"Could not access container: {e}")
    
    # Create a new event bus and return the debugger
    event_bus = EventBus()
    debugger.hook_event_bus(event_bus)
    return debugger, event_bus

def manual_debug_run():
    """Run a manual debugging session without using the backtest API."""
    import os
    import subprocess
    
    logger.info("Running manual debug session")
    
    # Create debugger
    debugger, event_bus = create_minimal_debugger()
    
    # Run main script in a subprocess
    logger.info("Running main script with custom event handlers attached")
    result = subprocess.run(['python', 'main.py'], 
                           capture_output=True, text=True, check=False)
    
    # Process results
    logger.info(f"Script output: {result.stdout}")
    if result.stderr:
        logger.error(f"Script errors: {result.stderr}")
        
    # Analyze captured events
    flow_analysis = debugger.analyze_event_flow()
    logger.info(f"Captured {flow_analysis['event_counts']['total']} events")
    
    return debugger

def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Debug ADMF-trader event flow')
    parser.add_argument('--config', '-c', type=str, default='config/head_test.yaml',
                        help='Configuration file path (default: config/head_test.yaml)')
    parser.add_argument('--output-dir', '-o', type=str, default='debug_results',
                        help='Output directory for debug files (default: debug_results)')
    parser.add_argument('--symbol', '-s', type=str, default=None,
                        help='Specific symbol to analyze in detail (default: all symbols)')
    parser.add_argument('--manual', '-m', action='store_true',
                        help='Run in manual debug mode (instead of using backtest API)')
    
    args = parser.parse_args()
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Determine debug mode
    if args.manual:
        logger.info("Using manual debug mode")
        debugger = manual_debug_run()
        result = None
    else:
        # Run backtest with debugger
        logger.info(f"Running backtest with config {args.config} and debugger attached")
        result, debugger = run_backtest_with_debugger(args.config)
    
    if debugger:
        # Save event data
        debugger.save_events(args.output_dir)
        
        # Analyze event flow
        flow_analysis = debugger.analyze_event_flow()
        
        # Save analysis
        with open(f"{args.output_dir}/flow_analysis.json", 'w') as f:
            json.dump(flow_analysis, f, indent=2)
            
        # Print summary
        logger.info("Event flow analysis:")
        logger.info(f"Total events captured: {flow_analysis['event_counts']['total']}")
        logger.info(f"Signals: {flow_analysis['event_counts']['signals']}")
        logger.info(f"Orders: {flow_analysis['event_counts']['orders']}")
        logger.info(f"Fills: {flow_analysis['event_counts']['fills']}")
        logger.info(f"Trade Opens: {flow_analysis['event_counts']['trade_opens']}")
        logger.info(f"Trade Closes: {flow_analysis['event_counts']['trade_closes']}")
        
        # Print issues
        if flow_analysis['flow_issues']:
            logger.warning(f"Found {len(flow_analysis['flow_issues'])} issues in event flow:")
            for issue in flow_analysis['flow_issues']:
                logger.warning(f"  - {issue}")
                
        if flow_analysis['position_issues']:
            logger.warning(f"Found {len(flow_analysis['position_issues'])} position issues:")
            for issue in flow_analysis['position_issues']:
                logger.warning(f"  - {issue}")
                
        # Analyze specific symbol if requested
        if args.symbol:
            symbol_analysis = analyze_symbol_events(args.symbol, debugger.events_by_symbol)
            
            # Save analysis
            with open(f"{args.output_dir}/symbol_{args.symbol}_analysis.json", 'w') as f:
                json.dump(symbol_analysis, f, indent=2)
                
            # Print summary
            logger.info(f"\nDetailed analysis for symbol {args.symbol}:")
            logger.info(f"Signals: {symbol_analysis.get('signals', 0)}")
            logger.info(f"  - Buy signals: {symbol_analysis.get('buy_signals', 0)}")
            logger.info(f"  - Sell signals: {symbol_analysis.get('sell_signals', 0)}")
            logger.info(f"  - Crossovers detected: {symbol_analysis.get('crossovers_detected', 0)}")
            logger.info(f"Orders: {symbol_analysis.get('orders', 0)}")
            logger.info(f"Fills: {symbol_analysis.get('fills', 0)}")
            logger.info(f"Trade Opens: {symbol_analysis.get('trade_opens', 0)}")
            logger.info(f"Trade Closes: {symbol_analysis.get('trade_closes', 0)}")
            
            # Print issues
            if 'issues' in symbol_analysis and symbol_analysis['issues']:
                logger.warning(f"Found {len(symbol_analysis['issues'])} issues for {args.symbol}:")
                for issue in symbol_analysis['issues']:
                    logger.warning(f"  - {issue}")
                    
        logger.info(f"\nDebug results saved to {args.output_dir}")
        logger.info("To identify the root cause, check the event flow analysis and the detailed event logs")
    else:
        logger.error("Failed to run backtest with debugger")
        
if __name__ == "__main__":
    main()