def analyze_backtest_log(log_path):
    """Analyze the backtest log file to identify issues."""
    # Initialize counters and storage
    signals = []
    orders = []
    fills = []
    trades = []
    warnings = []
    errors = []
    
    with open(log_path, 'r') as f:
        for line in f:
            line = line.strip()
            
            # Track signals
            if "Signal #" in line and "emitted for MINI" in line:
                signal_num = int(line.split("Signal #")[1].split(" ")[0])
                signal_type = 1 if "BUY signal" in line else -1 if "SELL signal" in line else 0
                signals.append((signal_num, signal_type))
            
            # Track orders
            if "Broker processed order:" in line:
                parts = line.split("Broker processed order: ")[1]
                direction, size, symbol, price = parts.split()
                price = price.replace("@", "").strip()
                timestamp = line.split(" - ")[0]
                orders.append({
                    'timestamp': timestamp,
                    'direction': direction, 
                    'size': int(size),
                    'symbol': symbol,
                    'price': float(price)
                })
            
            # Track fills
            if "Fill: " in line and "PnL:" in line:
                parts = line.split("Fill: ")[1].split(", ")
                direction = parts[0].split(" ")[0]
                size = int(parts[0].split(" ")[1])
                symbol = parts[0].split(" ")[2]
                price = float(parts[0].split(" ")[-1])
                pnl = float(parts[1].split(": ")[1])
                fills.append({
                    'direction': direction,
                    'size': size,
                    'symbol': symbol,
                    'price': price,
                    'pnl': pnl
                })
            
            # Track warnings
            if "WARNING" in line:
                warnings.append(line)
            
            # Track errors
            if "ERROR" in line:
                errors.append(line)
    
    # Process order information to find duplicates
    order_df = pd.DataFrame(orders)
    
    if not order_df.empty:
        # Convert timestamp to datetime for sorting
        order_df['timestamp'] = pd.to_datetime(order_df['timestamp'])
        
        # Sort by timestamp
        order_df = order_df.sort_values('timestamp')
        
        # Find pairs of orders that happen at the same timestamp
        order_df['time_group'] = order_df['timestamp'].astype(str)
        duplicate_groups = order_df.groupby('time_group').filter(lambda x: len(x) > 1)
        
        # Analyze position sizing behavior
        print(f"Total orders: {len(order_df)}")
        print(f"Unique timestamps: {order_df['timestamp'].nunique()}")
        print(f"Duplicate order groups: {len(duplicate_groups) // 2}")
        
        # Analyze fill information
        fill_df = pd.DataFrame(fills)
        
        if not fill_df.empty:
            print("\nFill Analysis:")
            print(f"Total fills: {len(fill_df)}")
            print(f"Average PnL: {fill_df['pnl'].mean():.2f}")
            print(f"Winning trades: {(fill_df['pnl'] > 0).sum()}")
            print(f"Losing trades: {(fill_df['pnl'] < 0).sum()}")
            print(f"Breakeven trades: {(fill_df['pnl'] == 0).sum()}")
        
        # Analyze warnings
        if warnings:
            print(f"\nWarnings: {len(warnings)}")
            warning_types = {}
            for w in warnings:
                key = w.split("WARNING - ")[1].split(":")[0]
                warning_types[key] = warning_types.get(key, 0) + 1
            
            print("Warning types:")
            for key, count in warning_types.items():
                print(f"  {key}: {count}")
        
        # Sample duplicate orders
        if not duplicate_groups.empty:
            print("\nSample duplicate order pairs:")
            for group, rows in duplicate_groups.groupby('time_group').head(2).groupby('time_group'):
                if len(rows) > 1:
                    print(f"\nTimestamp: {group}")
                    for i, row in rows.iterrows():
                        print(f"  {row['direction']} {row['size']} {row['symbol']} @ {row['price']}")
        
        return {
            'signals': signals,
            'orders': order_df,
            'fills': fill_df if not fill_df.empty else None,
            'warnings': warnings,
            'errors': errors
        }
    else:
        print("No orders found in log file.")
        return None

# Usage
log_path = 'paste.txt'  # Path to the log file
results = analyze_backtest_log(log_path)
